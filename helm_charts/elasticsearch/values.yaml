# Configuration for master nodepool
master:
  masterOnly: true
  replicaCount: 3
  heapSize: "512m"
  persistence:
    enabled: true
    storageClass: "azurefile-custom"
    size: "8Gi"
  tolerations:
  - key: "allow"
    value: "elastic-master"
    operator: "Equal"
    effect: "NoSchedule"
  resources:
    requests:
      memory: "1800Mi"
      cpu: "500m"
    limits:
      memory: "1800Mi"
      cpu: "2000m"
  nodeSelector:
    node_type: "elastic"
    node.kubernetes.io/component: "master"
  podAntiAffinityPreset: "hard" # Do not allow multiple master pods in the same K8S node
  autoscaling:
    enabled: false # Make this true to enable autoscaling
    minReplicas: 3
    maxReplicas: 11
    targetCPU: ""
    targetMemory: ""

# Configuration for data nodepool
data:
  replicaCount: 3
  heapSize: "1024m"
  nodeSelector:
    node_type: "elastic"
    node.kubernetes.io/component: "data"
  tolerations:
  - key: "allow"
    value: "elastic-data"
    operator: "Equal"
    effect: "NoSchedule"    
  persistence:
    enabled: true
    storageClass: "azurefile-custom"
    size: "20Gi"
  resources:
    requests:
      memory: "4096Mi"
      cpu: "500m"
    limits:
      memory: "4096Mi"
      cpu: "2000m"
  podAntiAffinityPreset: "hard" # Do not allow multiple data pods in the same K8S node
  autoscaling:
    enabled: false # Make this true to enable autoscaling
    minReplicas: 3
    maxReplicas: 11
    targetCPU: ""
    targetMemory: ""

# Configuration for coordinating nodepool
coordinating:
  replicaCount: 2
  heapSize: "256m"
  service:
    type: ClusterIP
  updateStrategy:
    type: RollingUpdate
  resources:
    requests:
      memory: "1024Mi"
      cpu: "200m"
    limits:
      memory: "1024Mi"
      cpu: "1000m"
  podAntiAffinityPreset: "hard" # Do not allow multiple coordinating pods in the same K8S node
  tolerations:
  - key: "allow"
    value: "elastic-coordinating"
    operator: "Equal"
    effect: "NoSchedule"
  nodeSelector:
    node_type: "elastic"
    node.kubernetes.io/component: "coordinating-only"

ingest:
  replicaCount: 0


#############################################################################
################# Use following for snapshots ###############################
#############################################################################
# snapshotRepoPath: "/bitnami/elasticsearch/backups"
# extraVolumes:
#   - name: snapshot-repository
#     persistentVolumeClaim:
#       claimName: pvc-es-snapshot
# extraVolumeMounts:
#   - name: snapshot-repository
#     mountPath: "/bitnami/elasticsearch/backups"
# extraEnvVars:
#   - name: ES_JAVA_OPTS
#     value: "-Dlog4j2.formatMsgNoLookups=true"


#############################################################################
################ Enable security by adding details below ####################
#############################################################################
# security:
#   ## @param security.enabled Enable X-Pack Security settings
#   ##
#   enabled: true
#   ## @param security.existingSecret Name of the existing secret containing the Elasticsearch password and
#   ##
#   existingSecret: ""
#   ## TLS configuration
#   ##
#   tls:
#     ## @param security.tls.restEncryption Enable SSL/TLS encryption for Elasticsearch REST API.
#     ##
#     restEncryption: true
#     ## @param security.tls.autoGenerated Create self-signed TLS certificates.
#     ## Note: Currently only supports PEM certificates.
#     ##
#     verificationMode: "full"
#     ## @param security.tls.master.existingSecret Existing secret containing the certificates for the master nodes
#     ## @param security.tls.data.existingSecret Existing secret containing the certificates for the data nodes
#     ## @param security.tls.ingest.existingSecret Existing secret containing the certificates for the ingest nodes
#     ## @param security.tls.coordinating.existingSecret Existing secret containing the certificates for the coordinating nodes
#     ##
#     master:
#       existingSecret: ""
#     data:
#       existingSecret: ""
#     ingest:
#       existingSecret: ""
#     coordinating:
#       existingSecret: ""
#     ## @param security.tls.keystoreFilename Name of the keystore file
#     ##
#     keystoreFilename: elasticsearch.keystore.jks
#     ## @param security.tls.truststoreFilename Name of the truststore
#     ##
#     truststoreFilename: elasticsearch.truststore.jks
#     ## @param security.tls.usePemCerts Use this variable if your secrets contain PEM certificates instead of JKS/PKCS12
#     ## Ignored when using autoGenerated certs.
#     ##
#     usePemCerts: false
#     ## @param security.tls.passwordsSecret Existing secret containing the Keystore and Truststore passwords, or key password if PEM certs are used
#     ##
#     passwordsSecret: ""
#     ## @param security.tls.keystorePassword Password to access the JKS/PKCS12 keystore or PEM key when they are password-protected.
#     ## Ignored if security.tls.passwordsSecret is provided.
#     ##
#     keystorePassword: ""
#     ## @param security.tls.truststorePassword Password to access the JKS/PKCS12 truststore when they are password-protected.
#     ## Ignored if security.tls.passwordsSecret is provided.
#     ##
#     truststorePassword: ""
#     ## @param security.tls.keyPassword Password to access the PEM key when they are password-protected.
#     ## Ignored if security.tls.passwordsSecret is provided.
#     ##
#     keyPassword: ""
#     ## @param security.tls.secretKeystoreKey Name of the secret key containing the Keystore password
#     ##
#     secretKeystoreKey: ""
#     ## @param security.tls.secretTruststoreKey Name of the secret key containing the Truststore password
#     ##
#     secretTruststoreKey: ""
#     ## @param security.tls.secretKey Name of the secret key containing the PEM key password
#     ##
#     secretKey: ""
